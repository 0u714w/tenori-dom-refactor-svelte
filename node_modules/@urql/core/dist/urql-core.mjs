import { visit as e } from "graphql/language/visitor.mjs";

import { Kind as t } from "graphql/language/kinds.mjs";

import { print as r } from "graphql/language/printer.mjs";

import { k as n, _ as i, s as o, C as u, m as s, a as c, b as p, c as l, d, e as v, f as y } from "./5adc38f0.mjs";

export { C as CombinedError, f as createRequest, h as getOperationName, a as makeErrorResult, m as makeResult, g as stringifyVariables } from "./5adc38f0.mjs";

import { toPromise as k, take as x, share as E, filter as O, map as b, tap as q, merge as w, mergeMap as D, takeUntil as N, make as _, onPush as S, makeSubject as T, subscribe as R, publish as P, onStart as M, onEnd as A, switchMap as V, fromValue as j } from "wonka";

function collectTypes(e, t) {
  if (Array.isArray(e)) {
    for (var r = 0; r < e.length; r++) {
      collectTypes(e[r], t);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var n in e) {
      if ("__typename" === n && "string" == typeof e[n]) {
        t[e[n]] = 0;
      } else {
        collectTypes(e[n], t);
      }
    }
  }
  return t;
}

function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}

var formatNode = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some((function(e) {
    return e.kind === t.FIELD && "__typename" === e.name.value && !e.alias;
  }))) {
    return i({}, e, {
      selectionSet: i({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([ {
          kind: t.FIELD,
          name: {
            kind: t.NAME,
            value: "__typename"
          }
        } ])
      })
    });
  }
};

var I = new Map;

function formatDocument(t) {
  var r = n(t);
  var i = I.get(r.__key);
  if (!i) {
    (i = e(r, {
      Field: formatNode,
      InlineFragment: formatNode
    })).__key = r.__key;
    I.set(r.__key, i);
  }
  return i;
}

function maskTypename(e) {
  if (!e || "object" != typeof e) {
    return e;
  }
  return Object.keys(e).reduce((function(t, r) {
    var n = e[r];
    if ("__typename" === r) {
      Object.defineProperty(t, "__typename", {
        enumerable: !1,
        value: n
      });
    } else if (Array.isArray(n)) {
      t[r] = n.map(maskTypename);
    } else if (n && "object" == typeof n && "__typename" in n) {
      t[r] = maskTypename(n);
    } else {
      t[r] = n;
    }
    return t;
  }), {});
}

function withPromise(e) {
  e.toPromise = function() {
    return k(x(1)(e));
  };
  return e;
}

function makeOperation(e, t, r) {
  if (!r) {
    r = t.context;
  }
  return {
    key: t.key,
    query: t.query,
    variables: t.variables,
    kind: e,
    context: r
  };
}

function addMetadata(e, t) {
  return makeOperation(e.kind, e, i({}, e.context, {
    meta: i({}, e.context.meta, t)
  }));
}

function noop() {}

function applyDefinitions(e, r, n) {
  for (var i = 0; i < n.length; i++) {
    if (n[i].kind === t.FRAGMENT_DEFINITION) {
      var a = n[i].name.value;
      var u = o(n[i]);
      if (!e.has(a)) {
        e.set(a, u);
        r.push(n[i]);
      } else if ("production" !== process.env.NODE_ENV && e.get(a) !== u) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + a + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      r.push(n[i]);
    }
  }
}

function gql() {
  var e = arguments;
  var r = new Map;
  var i = [];
  var a = [];
  var o = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u = 1; u < arguments.length; u++) {
    var s = e[u];
    if (s && s.definitions) {
      a.push.apply(a, s.definitions);
    } else {
      o += s;
    }
    o += e[0][u];
  }
  applyDefinitions(r, i, n(o).definitions);
  applyDefinitions(r, i, a);
  return n({
    kind: t.DOCUMENT,
    definitions: i
  });
}

function shouldSkip$1(e) {
  var t = e.kind;
  return "subscription" !== t && "query" !== t;
}

function ssrExchange(e) {
  var t = {};
  var r = [];
  function invalidate(e) {
    r.push(e.operation.key);
    if (1 === r.length) {
      Promise.resolve().then((function() {
        var e;
        while (e = r.shift()) {
          delete t[e];
        }
      }));
    }
  }
  function isCached(e) {
    return !shouldSkip$1(e) && void 0 !== t[e.key];
  }
  var ssr = function(r) {
    var n = r.client;
    var i = r.forward;
    return function(r) {
      var a = e && "boolean" == typeof e.isClient ? !!e.isClient : !n.suspense;
      var o = E(r);
      var s = i(O((function(e) {
        return !isCached(e);
      }))(o));
      var c = b((function(e) {
        return function deserializeResult(e, t) {
          var r = t.error;
          var n = t.data;
          return {
            operation: e,
            data: n ? JSON.parse(n) : void 0,
            extensions: void 0,
            error: r ? new u({
              networkError: r.networkError ? new Error(r.networkError) : void 0,
              graphQLErrors: r.graphQLErrors && r.graphQLErrors.length ? r.graphQLErrors : void 0
            }) : void 0
          };
        }(e, t[e.key]);
      }))(O((function(e) {
        return isCached(e);
      }))(o));
      if (!a) {
        s = q((function(e) {
          var r = e.operation;
          if (!shouldSkip$1(r)) {
            var n = function serializeResult(e) {
              var t = e.data;
              var r = e.error;
              var n = {};
              if (void 0 !== t) {
                n.data = JSON.stringify(t);
              }
              if (r) {
                n.error = {
                  graphQLErrors: r.graphQLErrors.map((function(e) {
                    if (!e.path && !e.extensions) {
                      return e.message;
                    }
                    return {
                      message: e.message,
                      path: e.path,
                      extensions: e.extensions
                    };
                  }))
                };
                if (r.networkError) {
                  n.error.networkError = "" + r.networkError;
                }
              }
              return n;
            }(e);
            t[r.key] = n;
          }
        }))(s);
      } else {
        c = q(invalidate)(c);
      }
      return w([ s, c ]);
    };
  };
  ssr.restoreData = function(e) {
    return i(t, e);
  };
  ssr.extractData = function() {
    return i({}, t);
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
}

function shouldSkip(e) {
  var t = e.kind;
  return "mutation" !== t && "query" !== t;
}

function cacheExchange(e) {
  var t = e.forward;
  var r = e.client;
  var n = e.dispatchDebug;
  var a = new Map;
  var o = Object.create(null);
  function mapTypeNames(e) {
    var t = makeOperation(e.kind, e);
    t.query = formatDocument(e.query);
    return t;
  }
  function isOperationCached(e) {
    var t = e.context.requestPolicy;
    return "query" === e.kind && "network-only" !== t && ("cache-only" === t || a.has(e.key));
  }
  return function(e) {
    var u = E(e);
    var s = b((function(e) {
      var t = a.get(e.key);
      "production" !== process.env.NODE_ENV && n(i({}, {
        operation: e
      }, t ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var o = i({}, t, {
        operation: addMetadata(e, {
          cacheOutcome: t ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e.context.requestPolicy) {
        o.stale = !0;
        reexecuteOperation(r, e);
      }
      return o;
    }))(O((function(e) {
      return !shouldSkip(e) && isOperationCached(e);
    }))(u));
    var c = q((function(e) {
      var t = e.operation;
      if (!t) {
        return;
      }
      var i = collectTypesFromResponse(e.data).concat(t.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        var u = new Set;
        "production" !== process.env.NODE_ENV && n({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + i,
          operation: t,
          data: {
            typenames: i,
            response: e
          },
          source: "cacheExchange"
        });
        for (var s = 0; s < i.length; s++) {
          var c = i[s];
          var p = o[c] || (o[c] = new Set);
          p.forEach((function(e) {
            u.add(e);
          }));
          p.clear();
        }
        u.forEach((function(e) {
          if (a.has(e)) {
            t = a.get(e).operation;
            a.delete(e);
            reexecuteOperation(r, t);
          }
        }));
      } else if ("query" === t.kind && e.data) {
        a.set(t.key, e);
        for (var f = 0; f < i.length; f++) {
          var l = i[f];
          (o[l] || (o[l] = new Set)).add(t.key);
        }
      }
    }))(t(O((function(e) {
      return "query" !== e.kind || "cache-only" !== e.context.requestPolicy;
    }))(b((function(e) {
      return addMetadata(e, {
        cacheOutcome: "miss"
      });
    }))(w([ b(mapTypeNames)(O((function(e) {
      return !shouldSkip(e) && !isOperationCached(e);
    }))(u)), O((function(e) {
      return shouldSkip(e);
    }))(u) ])))));
    return w([ s, c ]);
  };
}

function reexecuteOperation(e, t) {
  return e.reexecuteOperation(makeOperation(t.kind, t, i({}, t.context, {
    requestPolicy: "network-only"
  })));
}

function subscriptionExchange(e) {
  var t = e.forwardSubscription;
  var n = e.enableAllOperations;
  return function(e) {
    var a = e.client;
    var o = e.forward;
    function isSubscriptionOperation(e) {
      var t = e.kind;
      return "subscription" === t || !!n && ("query" === t || "mutation" === t);
    }
    return function(e) {
      var n = E(e);
      var u = D((function(e) {
        var o = e.key;
        var u = O((function(e) {
          return "teardown" === e.kind && e.key === o;
        }))(n);
        return N(u)(function createSubscriptionSource(e) {
          var n = t({
            key: e.key.toString(36),
            query: r(e.query),
            variables: e.variables,
            context: i({}, e.context)
          });
          return _((function(t) {
            var r = t.next;
            var i = t.complete;
            var o = !1;
            var u;
            Promise.resolve().then((function() {
              if (o) {
                return;
              }
              u = n.subscribe({
                next: function(t) {
                  return r(s(e, t));
                },
                error: function(t) {
                  return r(c(e, t));
                },
                complete: function() {
                  if (!o) {
                    o = !0;
                    if ("subscription" === e.kind) {
                      a.reexecuteOperation(makeOperation("teardown", e, e.context));
                    }
                    i();
                  }
                }
              });
            }));
            return function() {
              o = !0;
              if (u) {
                u.unsubscribe();
              }
            };
          }));
        }(e));
      }))(O(isSubscriptionOperation)(n));
      var p = o(O((function(e) {
        return !isSubscriptionOperation(e);
      }))(n));
      return w([ u, p ]);
    };
  };
}

function debugExchange(e) {
  var t = e.forward;
  if ("production" === process.env.NODE_ENV) {
    return function(e) {
      return t(e);
    };
  } else {
    return function(e) {
      return q((function(e) {
        return console.log("[Exchange debug]: Completed operation: ", e);
      }))(t(q((function(e) {
        return console.log("[Exchange debug]: Incoming operation: ", e);
      }))(e)));
    };
  }
}

function dedupExchange(e) {
  var t = e.forward;
  var r = e.dispatchDebug;
  var n = new Set;
  function filterIncomingOperation(e) {
    var t = e.key;
    var i = e.kind;
    if ("teardown" === i) {
      n.delete(t);
      return !0;
    }
    if ("query" !== i && "subscription" !== i) {
      return !0;
    }
    var a = n.has(t);
    n.add(t);
    if (a) {
      "production" !== process.env.NODE_ENV && r({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !a;
  }
  function afterOperationResult(e) {
    n.delete(e.operation.key);
  }
  return function(e) {
    var r = O(filterIncomingOperation)(e);
    return q(afterOperationResult)(t(r));
  };
}

function fetchExchange(e) {
  var t = e.forward;
  var r = e.dispatchDebug;
  return function(e) {
    var n = E(e);
    var i = D((function(e) {
      var t = e.key;
      var i = O((function(e) {
        return "teardown" === e.kind && e.key === t;
      }))(n);
      var a = p(e);
      var o = l(e, a);
      var u = d(e, a);
      "production" !== process.env.NODE_ENV && r({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e,
        data: {
          url: o,
          fetchOptions: u
        },
        source: "fetchExchange"
      });
      return S((function(t) {
        var n = !t.data ? t.error : void 0;
        "production" !== process.env.NODE_ENV && r({
          type: n ? "fetchError" : "fetchSuccess",
          message: "A " + (n ? "failed" : "successful") + " fetch response has been returned.",
          operation: e,
          data: {
            url: o,
            fetchOptions: u,
            value: n || t
          },
          source: "fetchExchange"
        });
      }))(N(i)(v(e, o, u)));
    }))(O((function(e) {
      return "query" === e.kind || "mutation" === e.kind;
    }))(n));
    var a = t(O((function(e) {
      return "query" !== e.kind && "mutation" !== e.kind;
    }))(n));
    return w([ i, a ]);
  };
}

function fallbackExchange(e) {
  var t = e.dispatchDebug;
  return function(e) {
    return O((function() {
      return !1;
    }))(q((function(e) {
      if ("teardown" !== e.kind && "production" !== process.env.NODE_ENV) {
        var r = 'No exchange has handled operations of kind "' + e.kind + "\". Check whether you've added an exchange responsible for these operations.";
        "production" !== process.env.NODE_ENV && t({
          type: "fallbackCatch",
          message: r,
          operation: e,
          source: "fallbackExchange"
        });
        console.warn(r);
      }
    }))(e));
  };
}

var $ = fallbackExchange({
  dispatchDebug: noop
});

function composeExchanges(e) {
  return function(t) {
    var r = t.client;
    var n = t.dispatchDebug;
    return e.reduceRight((function(e, t) {
      return t({
        client: r,
        forward: e,
        dispatchDebug: function dispatchDebug$1(e) {
          "production" !== process.env.NODE_ENV && n(i({}, {
            timestamp: Date.now(),
            source: t.name
          }, e));
        }
      });
    }), t.forward);
  };
}

function errorExchange(e) {
  var t = e.onError;
  return function(e) {
    var r = e.forward;
    return function(e) {
      return q((function(e) {
        var r = e.error;
        if (r) {
          t(r, e.operation);
        }
      }))(r(e));
    };
  };
}

var Q = [ dedupExchange, cacheExchange, fetchExchange ];

function createClient(e) {
  return new Client(e);
}

function Client(e) {
  var t = this;
  this.activeOperations = new Map;
  this.queue = [];
  this.createOperationContext = function(e) {
    if (!e) {
      e = {};
    }
    return i({}, {
      url: t.url,
      fetchOptions: t.fetchOptions,
      fetch: t.fetch,
      preferGetMethod: t.preferGetMethod
    }, e, {
      suspense: e.suspense || !1 !== e.suspense && t.suspense,
      requestPolicy: e.requestPolicy || t.requestPolicy
    });
  };
  this.createRequestOperation = function(e, r, n) {
    return makeOperation(e, r, t.createOperationContext(n));
  };
  this.executeQuery = function(e, r) {
    var n = t.createRequestOperation("query", e, r);
    return t.executeRequestOperation(n);
  };
  this.executeSubscription = function(e, r) {
    var n = t.createRequestOperation("subscription", e, r);
    return t.executeRequestOperation(n);
  };
  this.executeMutation = function(e, r) {
    var n = t.createRequestOperation("mutation", e, r);
    return t.executeRequestOperation(n);
  };
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = noop;
  if ("production" !== process.env.NODE_ENV) {
    var n = T();
    var a = n.next;
    var o = n.source;
    this.subscribeToDebugTarget = function(e) {
      return R(e)(o);
    };
    r = a;
  }
  this.url = e.url;
  this.fetchOptions = e.fetchOptions;
  this.fetch = e.fetch;
  this.suspense = !!e.suspense;
  this.requestPolicy = e.requestPolicy || "cache-first";
  this.preferGetMethod = !!e.preferGetMethod;
  this.maskTypename = !!e.maskTypename;
  var u = T();
  var s = u.next;
  this.operations$ = u.source;
  var c = !1;
  this.dispatchOperation = function(e) {
    c = !0;
    if (e) {
      s(e);
    }
    while (e = t.queue.shift()) {
      s(e);
    }
    c = !1;
  };
  this.reexecuteOperation = function(e) {
    if ("mutation" === e.kind || t.activeOperations.has(e.key)) {
      t.queue.push(e);
      if (!c) {
        Promise.resolve().then(t.dispatchOperation);
      }
    }
  };
  var p = composeExchanges(void 0 !== e.exchanges ? e.exchanges : Q);
  this.results$ = E(p({
    client: this,
    dispatchDebug: r,
    forward: fallbackExchange({
      dispatchDebug: r
    })
  })(this.operations$));
  P(this.results$);
}

Client.prototype.executeRequestOperation = function executeRequestOperation(e) {
  var t = this;
  var r = this.activeOperations.get(e.key);
  if (!r) {
    var n = O((function(t) {
      return t.operation.kind === e.kind && t.operation.key === e.key;
    }))(this.results$);
    if (this.maskTypename) {
      n = b((function(e) {
        return i({}, e, {
          data: maskTypename(e.data)
        });
      }))(n);
    }
    if ("mutation" === e.kind) {
      return x(1)(M((function() {
        return t.dispatchOperation(e);
      }))(n));
    }
    r = {
      source: E(A((function() {
        r.replay = null;
        t.activeOperations.delete(e.key);
        for (var n = t.queue.length - 1; n >= 0; n--) {
          if (t.queue[n].key === e.key) {
            t.queue.splice(n, 1);
          }
        }
        t.dispatchOperation(makeOperation("teardown", e, e.context));
      }))(S((function(e) {
        r.replay = e;
      }))(V((function(r) {
        if (r.stale) {
          return j(r);
        }
        return w([ j(r), b((function() {
          return i({}, r, {
            stale: !0
          });
        }))(x(1)(O((function(t) {
          return t.kind === e.kind && t.key === e.key && ("network-only" === t.context.requestPolicy || "cache-and-network" === t.context.requestPolicy);
        }))(t.operations$))) ]);
      }))(N(O((function(t) {
        return "teardown" === t.kind && t.key === e.key;
      }))(this.operations$))(n))))),
      replay: null
    };
  }
  var a = r.replay;
  var o = T();
  var u = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
  return M((function() {
    t.activeOperations.set(e.key, r);
    if ("subscription" === e.kind) {
      return t.dispatchOperation(e);
    } else if (u) {
      t.dispatchOperation(e);
    }
    if (null != a && a === r.replay) {
      o.next(u ? i({}, a, {
        stale: !0
      }) : a);
    } else if (!u) {
      t.dispatchOperation(e);
    }
  }))(w([ o.source, r.source ]));
};

Client.prototype.query = function query(e, t, r) {
  if (!r || "boolean" != typeof r.suspense) {
    r = i({}, r, {
      suspense: !1
    });
  }
  return withPromise(this.executeQuery(y(e, t), r));
};

Client.prototype.readQuery = function readQuery(e, t, r) {
  var n = null;
  R((function(e) {
    n = e;
  }))(this.query(e, t, r)).unsubscribe();
  return n;
};

Client.prototype.subscription = function subscription(e, t, r) {
  return this.executeSubscription(y(e, t), r);
};

Client.prototype.mutation = function mutation(e, t, r) {
  return withPromise(this.executeMutation(y(e, t), r));
};

export { Client, cacheExchange, composeExchanges, createClient, debugExchange, dedupExchange, Q as defaultExchanges, errorExchange, $ as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };
//# sourceMappingURL=urql-core.mjs.map
