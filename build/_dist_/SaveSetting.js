import './SaveSetting.css.proxy.js';
/* src/SaveSetting.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	action_destroyer,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	prevent_default,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text,
	transition_in,
	transition_out
} from "../web_modules/svelte/internal.js";

import { mutation } from "../web_modules/@urql/svelte.js";
import { tenoriState, nameState } from "./stores.js";
import Modal from "./Modal.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i][1];
	return child_ctx;
}

// (93:4) {#each Object.entries(errors) as [, error]}
function create_each_block(ctx) {
	let span;
	let t_value = /*error*/ ctx[14] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-1cb7hai");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*errors*/ 4 && t_value !== (t_value = /*error*/ ctx[14] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (82:0) <Modal bind:open {loading}>
function create_default_slot_1(ctx) {
	let form;
	let label;
	let t1;
	let input;
	let focus_action;
	let t2;
	let button;
	let i;
	let button_disabled_value;
	let t3;
	let mounted;
	let dispose;
	let each_value = Object.entries(/*errors*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			form = element("form");
			label = element("label");
			label.textContent = "Name Your Setting";
			t1 = space();
			input = element("input");
			t2 = space();
			button = element("button");
			i = element("i");
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(label, "for", "name");
			attr(input, "type", "text");
			attr(input, "id", "name");
			attr(input, "placeholder", "Moonlight Sonata");
			attr(input, "class", "svelte-1cb7hai");
			attr(i, "class", "fas fa-paper-plane");
			button.disabled = button_disabled_value = !/*settingName*/ ctx[1].length;
			attr(button, "type", "submit");
			attr(button, "class", "svelte-1cb7hai");
			attr(form, "class", "save-form svelte-1cb7hai");
		},
		m(target, anchor) {
			insert(target, form, anchor);
			append(form, label);
			append(form, t1);
			append(form, input);
			set_input_value(input, /*settingName*/ ctx[1]);
			append(form, t2);
			append(form, button);
			append(button, i);
			append(form, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form, null);
			}

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[9]),
					action_destroyer(focus_action = /*focus*/ ctx[7].call(null, input)),
					listen(form, "submit", prevent_default(/*submit_handler*/ ctx[10]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*settingName*/ 2 && input.value !== /*settingName*/ ctx[1]) {
				set_input_value(input, /*settingName*/ ctx[1]);
			}

			if (dirty & /*settingName*/ 2 && button_disabled_value !== (button_disabled_value = !/*settingName*/ ctx[1].length)) {
				button.disabled = button_disabled_value;
			}

			if (dirty & /*Object, errors*/ 4) {
				each_value = Object.entries(/*errors*/ ctx[2]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(form, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(form);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:0) <Modal open={!!successfulResult}>
function create_default_slot(ctx) {
	let div2;
	let div0;
	let t1;
	let div1;
	let small0;
	let t2_value = /*successfulResult*/ ctx[4].name + "";
	let t2;
	let t3;
	let small1;
	let t4_value = /*successfulResult*/ ctx[4].id + "";
	let t4;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			div0.textContent = "Saved sucessfully! If you'd like to recall this at a later time, save the name and id.";
			t1 = space();
			div1 = element("div");
			small0 = element("small");
			t2 = text(t2_value);
			t3 = space();
			small1 = element("small");
			t4 = text(t4_value);
			attr(small0, "class", "svelte-1cb7hai");
			attr(small1, "class", "svelte-1cb7hai");
			attr(div1, "class", "saved-result svelte-1cb7hai");
			attr(div2, "class", "result svelte-1cb7hai");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t1);
			append(div2, div1);
			append(div1, small0);
			append(small0, t2);
			append(div1, t3);
			append(div1, small1);
			append(small1, t4);
		},
		p(ctx, dirty) {
			if (dirty & /*successfulResult*/ 16 && t2_value !== (t2_value = /*successfulResult*/ ctx[4].name + "")) set_data(t2, t2_value);
			if (dirty & /*successfulResult*/ 16 && t4_value !== (t4_value = /*successfulResult*/ ctx[4].id + "")) set_data(t4, t4_value);
		},
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

function create_fragment(ctx) {
	let button;
	let t0;
	let modal0;
	let updating_open;
	let t1;
	let modal1;
	let current;
	let mounted;
	let dispose;

	function modal0_open_binding(value) {
		/*modal0_open_binding*/ ctx[11](value);
	}

	let modal0_props = {
		loading: /*loading*/ ctx[3],
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		modal0_props.open = /*open*/ ctx[0];
	}

	modal0 = new Modal({ props: modal0_props });
	binding_callbacks.push(() => bind(modal0, "open", modal0_open_binding));

	modal1 = new Modal({
			props: {
				open: !!/*successfulResult*/ ctx[4],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			button = element("button");
			button.innerHTML = `<i class="fas fa-save"></i>`;
			t0 = space();
			create_component(modal0.$$.fragment);
			t1 = space();
			create_component(modal1.$$.fragment);
			attr(button, "class", "svelte-1cb7hai");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			insert(target, t0, anchor);
			mount_component(modal0, target, anchor);
			insert(target, t1, anchor);
			mount_component(modal1, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*toggle*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const modal0_changes = {};
			if (dirty & /*loading*/ 8) modal0_changes.loading = /*loading*/ ctx[3];

			if (dirty & /*$$scope, settingName, errors*/ 131078) {
				modal0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				modal0_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			modal0.$set(modal0_changes);
			const modal1_changes = {};
			if (dirty & /*successfulResult*/ 16) modal1_changes.open = !!/*successfulResult*/ ctx[4];

			if (dirty & /*$$scope, successfulResult*/ 131088) {
				modal1_changes.$$scope = { dirty, ctx };
			}

			modal1.$set(modal1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal0.$$.fragment, local);
			transition_in(modal1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal0.$$.fragment, local);
			transition_out(modal1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (detaching) detach(t0);
			destroy_component(modal0, detaching);
			if (detaching) detach(t1);
			destroy_component(modal1, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $tenoriState;
	component_subscribe($$self, tenoriState, $$value => $$invalidate(12, $tenoriState = $$value));
	let { isSaving = false } = $$props;
	let open = false;
	let settingName = "";
	let errors = {};
	let loading = false;
	let successfulResult = false;

	const newSettingMutation = mutation({
		query: `
      mutation($setting: SettingInput! ) {
        createNewSetting(setting: $setting) {
          setting {
            id
            name
            value
          }
        }
      }
    `
	});

	const saveSetting = async name => {
		$$invalidate(2, errors = {});

		if (name.trim().length < 2) {
			$$invalidate(2, errors["name"] = "Must be at least 2 characters.", errors);
		}

		if (!$tenoriState.notes.flatMap(x => x.steps).some(({ status }) => !!status)) {
			$$invalidate(2, errors["empty"] = "Empty settings are boring...", errors);
		}

		if (Object.values(errors).length === 0) {
			const value = JSON.stringify($tenoriState);
			const result = await newSettingMutation({ setting: { name, value } });
			$$invalidate(3, loading = result.loading);
			$$invalidate(0, open = false);
			$$invalidate(1, settingName = "");

			if (result?.data?.createNewSetting?.setting) {
				$$invalidate(8, isSaving = true);
				const { id, value, name } = result.data.createNewSetting.setting;
				const newSetting = JSON.parse(value);
				nameState.update(() => name);
				$$invalidate(4, successfulResult = { name, id });

				tenoriState.update(store => {
					newSetting.play = false;

					if (store.play) {
						newSetting.play = true;
						return newSetting;
					}

					return newSetting;
				});
			}
		}
	};

	function toggle() {
		$$invalidate(2, errors = {});
		$$invalidate(0, open = !open);
		$$invalidate(4, successfulResult = false);
		$$invalidate(1, settingName = "");
	}

	function focus(element) {
		$$invalidate(1, settingName = "");
		element.focus();
	}

	function input_input_handler() {
		settingName = this.value;
		$$invalidate(1, settingName);
	}

	const submit_handler = () => saveSetting(settingName);

	function modal0_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ("isSaving" in $$props) $$invalidate(8, isSaving = $$props.isSaving);
	};

	return [
		open,
		settingName,
		errors,
		loading,
		successfulResult,
		saveSetting,
		toggle,
		focus,
		isSaving,
		input_input_handler,
		submit_handler,
		modal0_open_binding
	];
}

class SaveSetting extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { isSaving: 8 });
	}
}

export default SaveSetting;